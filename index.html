<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Secret Santa</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { max-width: 720px; margin: 40px auto; padding: 0 16px; }
    .card { border: 1px solid #e5e7eb; border-radius: 12px; padding: 16px; box-shadow: 0 1px 6px rgba(0,0,0,0.05); }
    label { display: block; margin: 12px 0 6px; font-weight: 600; }
    select, button { font-size: 16px; padding: 10px 12px; border-radius: 10px; border: 1px solid #d1d5db; }
    button { cursor: pointer; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .result { margin-top: 14px; padding: 12px; border-radius: 10px; background: #f9fafb; border: 1px solid #e5e7eb; }
    .small { color: #6b7280; font-size: 13px; margin-top: 10px; line-height: 1.35; }
    code { background: #f3f4f6; padding: 2px 6px; border-radius: 6px; }
  </style>
</head>
<body>
  <h1>üéÅ Secret Santa</h1>

  <div class="card">
    <p>Select your name and click <b>Reveal</b>.</p>

    <label for="nameSelect">Your name</label>
    <div class="row">
      <select id="nameSelect"></select>
      <button id="revealBtn">Reveal</button>
      <button id="regenerateBtn" type="button" title="For organizer/testing only">Regenerate</button>
    </div>

    <div id="result" class="result" style="display:none;"></div>

    <div class="small">
      Note: This is a static page. Anyone can open DevTools and see the full assignment in the source/runtime.
      If you need real secrecy, ask for the ‚Äúencrypted reveal‚Äù variant.
    </div>
  </div>

  <script>
    /********************
     * 1) CONFIG
     ********************/

    // Hardcode participants here:
    const participants = [
      "Andy",
      "Cody",
      "Dani",
      "Greg",
      "Rebecca",
      "Sam",
    ];

    // Hardcode forbidden pair tuples here (symmetric will be enforced automatically):
    // Meaning: A cannot give to B, and B cannot give to A.
    const forbiddenPairs = [
      ["Cody", "Rebecca"],
      // ["Sam", "Greg"],
    ];

    // If you change participants/constraints and want a different (but deterministic) draw,
    // change this seed string. (Still not ‚Äúsecure‚Äù, just stable.)
    const DRAW_SEED = "secret-santa-2025-books";


    /********************
     * 2) SEEDED RNG (deterministic)
     ********************/
    function xmur3(str) {
      let h = 1779033703 ^ str.length;
      for (let i = 0; i < str.length; i++) {
        h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
        h = (h << 13) | (h >>> 19);
      }
      return function() {
        h = Math.imul(h ^ (h >>> 16), 2246822507);
        h = Math.imul(h ^ (h >>> 13), 3266489909);
        h ^= (h >>> 16);
        return h >>> 0;
      };
    }

    function mulberry32(seed) {
      return function() {
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }

    function makeRng(seedStr) {
      const seedGen = xmur3(seedStr);
      return mulberry32(seedGen());
    }

    function shuffleInPlace(arr, rng) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }


    /********************
     * 3) CONSTRAINTS + GENERATOR
     ********************/
    function pairKey(a, b) {
      return `${a}||${b}`;
    }

    function buildForbiddenSet(pairs) {
      const s = new Set();
      for (const [a, b] of pairs) {
        s.add(pairKey(a, b));
        s.add(pairKey(b, a)); // enforce symmetry
      }
      return s;
    }

    function validateInput(names, forbiddenSet) {
      const uniq = new Set(names);
      if (uniq.size !== names.length) {
        throw new Error("Participants list contains duplicates.");
      }
      if (names.length < 2) {
        throw new Error("Need at least 2 participants.");
      }
      for (const n of names) {
        if (forbiddenSet.has(pairKey(n, n))) {
          throw new Error(`Invalid forbidden pair: ${n} cannot be paired with themselves (already disallowed).`);
        }
      }
    }

    function generateAssignments(names, forbiddenSet, rng) {
      // Try multiple randomized attempts (still deterministic due to seeded rng).
      const MAX_ATTEMPTS = 500;

      function isForbidden(giver, receiver) {
        return forbiddenSet.has(pairKey(giver, receiver));
      }

      for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {
        const giverOrder = names.slice();
        shuffleInPlace(giverOrder, rng);

        const usedReceivers = new Set();
        const assignment = Object.create(null);

        function backtrack(i) {
          if (i === giverOrder.length) return true;

          const giver = giverOrder[i];
          const candidates = [];

          for (const receiver of names) {
            if (usedReceivers.has(receiver)) continue;
            if (receiver === giver) continue;
            if (isForbidden(giver, receiver)) continue;
            candidates.push(receiver);
          }

          shuffleInPlace(candidates, rng);

          for (const receiver of candidates) {
            assignment[giver] = receiver;
            usedReceivers.add(receiver);

            if (backtrack(i + 1)) return true;

            usedReceivers.delete(receiver);
            delete assignment[giver];
          }
          return false;
        }

        if (backtrack(0)) {
          // Normalize result into original names order (just for predictable object)
          const normalized = Object.create(null);
          for (const giver of names) normalized[giver] = assignment[giver];
          return normalized;
        }
      }

      throw new Error(
        "Could not find a valid assignment with the current constraints. " +
        "Try removing some forbidden pairs or adding participants."
      );
    }


    /********************
     * 4) UI WIRING
     ********************/
    const forbiddenSet = buildForbiddenSet(forbiddenPairs);
    validateInput(participants, forbiddenSet);

    const selectEl = document.getElementById("nameSelect");
    const resultEl = document.getElementById("result");
    const revealBtn = document.getElementById("revealBtn");
    const regenerateBtn = document.getElementById("regenerateBtn");

    for (const name of participants) {
      const opt = document.createElement("option");
      opt.value = name;
      opt.textContent = name;
      selectEl.appendChild(opt);
    }

    let rng = makeRng(DRAW_SEED);
    let assignments = generateAssignments(participants, forbiddenSet, rng);

    function showAssignment() {
      const name = selectEl.value;
      const receiver = assignments[name];

      resultEl.style.display = "block";
      resultEl.innerHTML = `
        <div><b>${escapeHtml(name)}</b>, you are Secret Santa for:</div>
        <div style="font-size: 22px; margin-top: 6px;"><b>${escapeHtml(receiver)}</b> üéÑ</div>
      `;
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    revealBtn.addEventListener("click", showAssignment);

    regenerateBtn.addEventListener("click", () => {
      // Organizer/testing convenience: ‚Äúnew‚Äù deterministic draw by nudging the seed.
      // This stays deterministic per click sequence on this page, but different people/devices will differ.
      // For a real new draw: change DRAW_SEED in the code and redeploy.
      rng = makeRng(DRAW_SEED + "::" + Date.now());
      assignments = generateAssignments(participants, forbiddenSet, rng);
      resultEl.style.display = "none";
    });
  </script>
</body>
</html>
